<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>FBXpythonSDKdoxygen01100: FbxGeometryConverter クラス</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="Fbx_launch.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">FBXpythonSDKdoxygen01100
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- 構築: Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'検索');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','検索');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">公開メンバ関数</a> &#124;
<a href="#friends">フレンド</a> &#124;
<a href="class_fbx_geometry_converter-members.html">全メンバ一覧</a>  </div>
  <div class="headertitle">
<div class="title">FbxGeometryConverter クラス</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="fbxgeometryconverter_8h_source.html">fbxgeometryconverter.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
公開メンバ関数</h2></td></tr>
<tr class="memitem:a26aa6da6240c0293e449958f8a58a779"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_fbx_geometry_converter.html#a26aa6da6240c0293e449958f8a58a779">RecenterSceneToWorldCenter</a> (<a class="el" href="class_fbx_scene.html">FbxScene</a> *pScene, <a class="el" href="fbxtypes_8h.html#a171e72a1c46fc15c1a6c9c31948c1c5b">FbxDouble</a> pThreshold)</td></tr>
<tr class="separator:a26aa6da6240c0293e449958f8a58a779"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0870c4520e42e88aaed5c5a8cca0c7ec"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_fbx_node.html">FbxNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_fbx_geometry_converter.html#a0870c4520e42e88aaed5c5a8cca0c7ec">MergeMeshes</a> (<a class="el" href="class_fbx_array.html">FbxArray</a>&lt; <a class="el" href="class_fbx_node.html">FbxNode</a> *&gt; &amp;pMeshNodes, const char *pNodeName, <a class="el" href="class_fbx_scene.html">FbxScene</a> *pScene)</td></tr>
<tr class="separator:a0870c4520e42e88aaed5c5a8cca0c7ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9f8c321399875d9d5df3ae49ebf428d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_fbx_geometry_converter.html#ae9f8c321399875d9d5df3ae49ebf428d">RemoveBadPolygonsFromMeshes</a> (<a class="el" href="class_fbx_scene.html">FbxScene</a> *pScene, <a class="el" href="class_fbx_array.html">FbxArray</a>&lt; <a class="el" href="class_fbx_node.html">FbxNode</a> *&gt; *pAffectedNodes=<a class="el" href="fbxarch_8h.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>)</td></tr>
<tr class="separator:ae9f8c321399875d9d5df3ae49ebf428d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6eada73a1b581c807d55b44941d3d7be"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_fbx_geometry_converter.html#a6eada73a1b581c807d55b44941d3d7be">FbxGeometryConverter</a> (<a class="el" href="class_fbx_manager.html">FbxManager</a> *pManager)</td></tr>
<tr class="separator:a6eada73a1b581c807d55b44941d3d7be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3950419ba338daaa002afc4e73d70fa"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_fbx_geometry_converter.html#ab3950419ba338daaa002afc4e73d70fa">~FbxGeometryConverter</a> ()</td></tr>
<tr class="separator:ab3950419ba338daaa002afc4e73d70fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
フレンド</h2></td></tr>
<tr class="memitem:af608b805e0fdfadf8f73af0f1e948bf5"><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_fbx_geometry_converter.html#af608b805e0fdfadf8f73af0f1e948bf5">FbxWriter3ds</a></td></tr>
<tr class="separator:af608b805e0fdfadf8f73af0f1e948bf5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Triangulation Utilities</h2></td></tr>
<tr class="memitem:a472eeb2876199b239ce84807a5b4812b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_fbx_geometry_converter.html#a472eeb2876199b239ce84807a5b4812b">Triangulate</a> (<a class="el" href="class_fbx_scene.html">FbxScene</a> *pScene, bool pReplace, bool pLegacy=false)</td></tr>
<tr class="separator:a472eeb2876199b239ce84807a5b4812b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeef7518f4f50b7afc7e7f429eef8aa8d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_fbx_node_attribute.html">FbxNodeAttribute</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_fbx_geometry_converter.html#aeef7518f4f50b7afc7e7f429eef8aa8d">Triangulate</a> (<a class="el" href="class_fbx_node_attribute.html">FbxNodeAttribute</a> *pNodeAttribute, bool pReplace, bool pLegacy=false)</td></tr>
<tr class="separator:aeef7518f4f50b7afc7e7f429eef8aa8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ee0a5af2ed44232dfda82fecd00a875"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_fbx_geometry_converter.html#a3ee0a5af2ed44232dfda82fecd00a875">ComputeGeometryControlPointsWeightedMapping</a> (<a class="el" href="class_fbx_geometry.html">FbxGeometry</a> *pSrcGeom, <a class="el" href="class_fbx_geometry.html">FbxGeometry</a> *pDstGeom, <a class="el" href="class_fbx_weighted_mapping.html">FbxWeightedMapping</a> *pSrcToDstWeightedMapping, bool pSwapUV=false)</td></tr>
<tr class="separator:a3ee0a5af2ed44232dfda82fecd00a875"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Geometry Conversion</h2></td></tr>
<tr class="memitem:a3164d027c0c9251642f8e48f6a59f662"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_fbx_nurbs.html">FbxNurbs</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_fbx_geometry_converter.html#a3164d027c0c9251642f8e48f6a59f662">ConvertPatchToNurbs</a> (<a class="el" href="class_fbx_patch.html">FbxPatch</a> *pPatch)</td></tr>
<tr class="separator:a3164d027c0c9251642f8e48f6a59f662"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc457be0a21f7566ff8bdd0d9a704b46"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_fbx_geometry_converter.html#acc457be0a21f7566ff8bdd0d9a704b46">ConvertPatchToNurbsInPlace</a> (<a class="el" href="class_fbx_node.html">FbxNode</a> *pNode)</td></tr>
<tr class="separator:acc457be0a21f7566ff8bdd0d9a704b46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c29f94bf91e84d6ee4e665ed9632e09"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_fbx_nurbs_surface.html">FbxNurbsSurface</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_fbx_geometry_converter.html#a8c29f94bf91e84d6ee4e665ed9632e09">ConvertPatchToNurbsSurface</a> (<a class="el" href="class_fbx_patch.html">FbxPatch</a> *pPatch)</td></tr>
<tr class="separator:a8c29f94bf91e84d6ee4e665ed9632e09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd5bc619771c69c680b2da7ae4d0c2e4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_fbx_geometry_converter.html#afd5bc619771c69c680b2da7ae4d0c2e4">ConvertPatchToNurbsSurfaceInPlace</a> (<a class="el" href="class_fbx_node.html">FbxNode</a> *pNode)</td></tr>
<tr class="separator:afd5bc619771c69c680b2da7ae4d0c2e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33fe5cce26020e2687dcd1b1e05109a4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_fbx_nurbs_surface.html">FbxNurbsSurface</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_fbx_geometry_converter.html#a33fe5cce26020e2687dcd1b1e05109a4">ConvertNurbsToNurbsSurface</a> (<a class="el" href="class_fbx_nurbs.html">FbxNurbs</a> *pNurbs)</td></tr>
<tr class="separator:a33fe5cce26020e2687dcd1b1e05109a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeccff6de5e2abd1f8625147b5e061b8b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_fbx_nurbs.html">FbxNurbs</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_fbx_geometry_converter.html#aeccff6de5e2abd1f8625147b5e061b8b">ConvertNurbsSurfaceToNurbs</a> (<a class="el" href="class_fbx_nurbs_surface.html">FbxNurbsSurface</a> *pNurbs)</td></tr>
<tr class="separator:aeccff6de5e2abd1f8625147b5e061b8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8662fd4c468b6e18b276f3ef353fe2f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_fbx_geometry_converter.html#ae8662fd4c468b6e18b276f3ef353fe2f">ConvertNurbsToNurbsSurfaceInPlace</a> (<a class="el" href="class_fbx_node.html">FbxNode</a> *pNode)</td></tr>
<tr class="separator:ae8662fd4c468b6e18b276f3ef353fe2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82c9ea1ab75c8eefd555b4c538f3bbb7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_fbx_geometry_converter.html#a82c9ea1ab75c8eefd555b4c538f3bbb7">ConvertNurbsSurfaceToNurbsInPlace</a> (<a class="el" href="class_fbx_node.html">FbxNode</a> *pNode)</td></tr>
<tr class="separator:a82c9ea1ab75c8eefd555b4c538f3bbb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Nurb UV and Links Swapping</h2></td></tr>
<tr class="memitem:a5b6352d91ef28ac20c8b759496064fa3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_fbx_nurbs.html">FbxNurbs</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_fbx_geometry_converter.html#a5b6352d91ef28ac20c8b759496064fa3">FlipNurbs</a> (<a class="el" href="class_fbx_nurbs.html">FbxNurbs</a> *pNurbs, bool pSwapUV, bool pSwapClusters)</td></tr>
<tr class="separator:a5b6352d91ef28ac20c8b759496064fa3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fcc73c0f44390bf3ac13f8a796e34de"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_fbx_nurbs_surface.html">FbxNurbsSurface</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_fbx_geometry_converter.html#a1fcc73c0f44390bf3ac13f8a796e34de">FlipNurbsSurface</a> (<a class="el" href="class_fbx_nurbs_surface.html">FbxNurbsSurface</a> *pNurbs, bool pSwapUV, bool pSwapClusters)</td></tr>
<tr class="separator:a1fcc73c0f44390bf3ac13f8a796e34de"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Normals By Polygon Vertex Emulation</h2></td></tr>
<tr class="memitem:a3c79ca6723b51b564842b9563f67102f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_fbx_geometry_converter.html#a3c79ca6723b51b564842b9563f67102f">EmulateNormalsByPolygonVertex</a> (<a class="el" href="class_fbx_mesh.html">FbxMesh</a> *pMesh)</td></tr>
<tr class="separator:a3c79ca6723b51b564842b9563f67102f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf3f1e784136f58c62d8516777825bf7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_fbx_geometry_converter.html#acf3f1e784136f58c62d8516777825bf7">ComputeEdgeSmoothingFromNormals</a> (<a class="el" href="class_fbx_mesh.html">FbxMesh</a> *pMesh) const</td></tr>
<tr class="separator:acf3f1e784136f58c62d8516777825bf7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82e299d731d7e52443f7f0c7aaa61ce4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_fbx_geometry_converter.html#a82e299d731d7e52443f7f0c7aaa61ce4">ComputePolygonSmoothingFromEdgeSmoothing</a> (<a class="el" href="class_fbx_mesh.html">FbxMesh</a> *pMesh, int pIndex=0) const</td></tr>
<tr class="separator:a82e299d731d7e52443f7f0c7aaa61ce4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65bb00283eddbd2e2c34b723e134d147"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_fbx_geometry_converter.html#a65bb00283eddbd2e2c34b723e134d147">ComputeEdgeSmoothingFromPolygonSmoothing</a> (<a class="el" href="class_fbx_mesh.html">FbxMesh</a> *pMesh, int pIndex=0) const</td></tr>
<tr class="separator:a65bb00283eddbd2e2c34b723e134d147"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Split Mesh Per Materials</h2></td></tr>
<tr class="memitem:aed7a7dd03d949e08e008262fd5b57421"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_fbx_geometry_converter.html#aed7a7dd03d949e08e008262fd5b57421">SplitMeshesPerMaterial</a> (<a class="el" href="class_fbx_scene.html">FbxScene</a> *pScene, bool pReplace)</td></tr>
<tr class="separator:aed7a7dd03d949e08e008262fd5b57421"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b48927a9d9394344598d1e9e80499bf"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_fbx_geometry_converter.html#a3b48927a9d9394344598d1e9e80499bf">SplitMeshPerMaterial</a> (<a class="el" href="class_fbx_mesh.html">FbxMesh</a> *pMesh, bool pReplace)</td></tr>
<tr class="separator:a3b48927a9d9394344598d1e9e80499bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">詳解</h2>
<div class="textblock"><p>This class provides the functionality to convert geometry nodes attributes (<a class="el" href="class_fbx_mesh.html">FbxMesh</a>, <a class="el" href="class_fbx_nurbs.html">FbxNurbs</a> and <a class="el" href="class_fbx_patch.html">FbxPatch</a>) and mainly focuses on the two major categories: Triangulation and conversion between NURBS and Patches surfaces. </p>
</div><h2 class="groupheader">構築子と解体子</h2>
<a id="a6eada73a1b581c807d55b44941d3d7be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6eada73a1b581c807d55b44941d3d7be">&#9670;&nbsp;</a></span>FbxGeometryConverter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FbxGeometryConverter::FbxGeometryConverter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_fbx_manager.html">FbxManager</a> *&#160;</td>
          <td class="paramname"><em>pManager</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab3950419ba338daaa002afc4e73d70fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3950419ba338daaa002afc4e73d70fa">&#9670;&nbsp;</a></span>~FbxGeometryConverter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FbxGeometryConverter::~FbxGeometryConverter </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">メソッド詳解</h2>
<a id="acf3f1e784136f58c62d8516777825bf7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf3f1e784136f58c62d8516777825bf7">&#9670;&nbsp;</a></span>ComputeEdgeSmoothingFromNormals()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool FbxGeometryConverter::ComputeEdgeSmoothingFromNormals </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_fbx_mesh.html">FbxMesh</a> *&#160;</td>
          <td class="paramname"><em>pMesh</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create edge smoothing information from polygon-vertex mapped normals. Existing smoothing information is removed and edge data is created if none exists on the mesh. </p><dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">pMesh</td><td>The mesh used to generate edge smoothing. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd><code>true</code> on success, <code>false</code> otherwise. </dd></dl>
<dl class="section remark"><dt>注釈</dt><dd>The edge smoothing data is placed on Layer 0 of the mesh. Normals do not need to be on Layer 0, since the first layer with per polygon vertex normals is used. </dd></dl>

</div>
</div>
<a id="a65bb00283eddbd2e2c34b723e134d147"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65bb00283eddbd2e2c34b723e134d147">&#9670;&nbsp;</a></span>ComputeEdgeSmoothingFromPolygonSmoothing()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool FbxGeometryConverter::ComputeEdgeSmoothingFromPolygonSmoothing </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_fbx_mesh.html">FbxMesh</a> *&#160;</td>
          <td class="paramname"><em>pMesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>pIndex</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Convert polygon smoothing group to edge smoothing. Existing smoothing information is replaced.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">pMesh</td><td>The mesh that contains the smoothing to be converted. </td></tr>
    <tr><td class="paramname">pIndex</td><td>The index of the layer smoothing to be converted </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd><code>true</code> on success, <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="a3ee0a5af2ed44232dfda82fecd00a875"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ee0a5af2ed44232dfda82fecd00a875">&#9670;&nbsp;</a></span>ComputeGeometryControlPointsWeightedMapping()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool FbxGeometryConverter::ComputeGeometryControlPointsWeightedMapping </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_fbx_geometry.html">FbxGeometry</a> *&#160;</td>
          <td class="paramname"><em>pSrcGeom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_fbx_geometry.html">FbxGeometry</a> *&#160;</td>
          <td class="paramname"><em>pDstGeom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_fbx_weighted_mapping.html">FbxWeightedMapping</a> *&#160;</td>
          <td class="paramname"><em>pSrcToDstWeightedMapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>pSwapUV</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute a "vertex-correspondence" table that helps passing from source to destination geometry. </p><dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">pSrcGeom</td><td>Pointer to the source geometry. </td></tr>
    <tr><td class="paramname">pDstGeom</td><td>Pointer to the destination geometry. </td></tr>
    <tr><td class="paramname">pSrcToDstWeightedMapping</td><td>Pointer to the weighted mapping table. </td></tr>
    <tr><td class="paramname">pSwapUV</td><td>Set to <code>true</code> to swap UVs. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd><code>true</code> on success, <code>false</code> if the function fails to compute the correspondence. </dd></dl>
<dl class="section remark"><dt>注釈</dt><dd>Skins and shapes are also converted to fit the alternate geometry. </dd></dl>

</div>
</div>
<a id="a82e299d731d7e52443f7f0c7aaa61ce4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82e299d731d7e52443f7f0c7aaa61ce4">&#9670;&nbsp;</a></span>ComputePolygonSmoothingFromEdgeSmoothing()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool FbxGeometryConverter::ComputePolygonSmoothingFromEdgeSmoothing </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_fbx_mesh.html">FbxMesh</a> *&#160;</td>
          <td class="paramname"><em>pMesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>pIndex</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Convert edge smoothing to polygon smoothing group. Existing smoothing information is replaced.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">pMesh</td><td>The mesh that contains the smoothing to be converted. </td></tr>
    <tr><td class="paramname">pIndex</td><td>The index of the layer smoothing to be converted. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd><code>true</code> on success, <code>false</code> otherwise. </dd></dl>
<dl class="section remark"><dt>注釈</dt><dd>The smoothing group is bitwise. Each bit of the integer represents one smoothing group. Therefore, there is a maximum of 32 smoothing groups. </dd></dl>

</div>
</div>
<a id="aeccff6de5e2abd1f8625147b5e061b8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeccff6de5e2abd1f8625147b5e061b8b">&#9670;&nbsp;</a></span>ConvertNurbsSurfaceToNurbs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_fbx_nurbs.html">FbxNurbs</a>* FbxGeometryConverter::ConvertNurbsSurfaceToNurbs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_fbx_nurbs_surface.html">FbxNurbsSurface</a> *&#160;</td>
          <td class="paramname"><em>pNurbs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Convert a <a class="el" href="class_fbx_nurbs_surface.html">FbxNurbsSurface</a> to a <a class="el" href="class_fbx_nurbs.html">FbxNurbs</a> </p><dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">pNurbs</td><td>Pointer to the original nurbs surface </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>A <a class="el" href="class_fbx_nurbs.html">FbxNurbs</a> that is equivalent to the original nurbs surface. </dd></dl>

</div>
</div>
<a id="a82c9ea1ab75c8eefd555b4c538f3bbb7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82c9ea1ab75c8eefd555b4c538f3bbb7">&#9670;&nbsp;</a></span>ConvertNurbsSurfaceToNurbsInPlace()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool FbxGeometryConverter::ConvertNurbsSurfaceToNurbsInPlace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_fbx_node.html">FbxNode</a> *&#160;</td>
          <td class="paramname"><em>pNode</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Convert a nurb contained in a node to a nurbs surface. Use this function to preserve the nurb's skins and shapes animation channels. </p><dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">pNode</td><td>Pointer to the node containing the nurbs surface. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd><code>true</code> on success, <code>false</code> otherwise </dd></dl>

</div>
</div>
<a id="a33fe5cce26020e2687dcd1b1e05109a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33fe5cce26020e2687dcd1b1e05109a4">&#9670;&nbsp;</a></span>ConvertNurbsToNurbsSurface()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_fbx_nurbs_surface.html">FbxNurbsSurface</a>* FbxGeometryConverter::ConvertNurbsToNurbsSurface </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_fbx_nurbs.html">FbxNurbs</a> *&#160;</td>
          <td class="paramname"><em>pNurbs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Convert a <a class="el" href="class_fbx_nurbs.html">FbxNurbs</a> to a <a class="el" href="class_fbx_nurbs_surface.html">FbxNurbsSurface</a> </p><dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">pNurbs</td><td>Pointer to the original nurb </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>A <a class="el" href="class_fbx_nurbs_surface.html">FbxNurbsSurface</a> that is equivalent to the original nurb. </dd></dl>

</div>
</div>
<a id="ae8662fd4c468b6e18b276f3ef353fe2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8662fd4c468b6e18b276f3ef353fe2f">&#9670;&nbsp;</a></span>ConvertNurbsToNurbsSurfaceInPlace()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool FbxGeometryConverter::ConvertNurbsToNurbsSurfaceInPlace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_fbx_node.html">FbxNode</a> *&#160;</td>
          <td class="paramname"><em>pNode</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Convert a nurb, contained in a node, to a nurbs surface. Use this function to preserve the nurb's skins and shapes animation channels. </p><dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">pNode</td><td>Pointer to the node containing the nurb. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd><code>true</code> on success, <code>false</code> otherwise </dd></dl>

</div>
</div>
<a id="a3164d027c0c9251642f8e48f6a59f662"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3164d027c0c9251642f8e48f6a59f662">&#9670;&nbsp;</a></span>ConvertPatchToNurbs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_fbx_nurbs.html">FbxNurbs</a>* FbxGeometryConverter::ConvertPatchToNurbs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_fbx_patch.html">FbxPatch</a> *&#160;</td>
          <td class="paramname"><em>pPatch</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Convert from patch to nurb. </p><dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">pPatch</td><td>Pointer to the patch to convert. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>Created nurb or <code>NULL</code> if the conversion fails. </dd></dl>
<dl class="section remark"><dt>注釈</dt><dd>The patch must be of type eBSpline, eBezier or eLinear. </dd></dl>

</div>
</div>
<a id="acc457be0a21f7566ff8bdd0d9a704b46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc457be0a21f7566ff8bdd0d9a704b46">&#9670;&nbsp;</a></span>ConvertPatchToNurbsInPlace()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool FbxGeometryConverter::ConvertPatchToNurbsInPlace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_fbx_node.html">FbxNode</a> *&#160;</td>
          <td class="paramname"><em>pNode</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Convert a patch contained in a node to a nurb. Use this function to preserve the patch's skins and shapes animation channels. </p><dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">pNode</td><td>Pointer to the node containing the patch. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd><code>true</code> on success, <code>false</code> if the node attribute is not a patch. </dd></dl>
<dl class="section remark"><dt>注釈</dt><dd>The patch must be of type eBSpline, eBezier or eLinear. </dd></dl>

</div>
</div>
<a id="a8c29f94bf91e84d6ee4e665ed9632e09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c29f94bf91e84d6ee4e665ed9632e09">&#9670;&nbsp;</a></span>ConvertPatchToNurbsSurface()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_fbx_nurbs_surface.html">FbxNurbsSurface</a>* FbxGeometryConverter::ConvertPatchToNurbsSurface </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_fbx_patch.html">FbxPatch</a> *&#160;</td>
          <td class="paramname"><em>pPatch</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Convert a patch to nurb surface. </p><dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">pPatch</td><td>Pointer to the patch to convert. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>Created nurb surface or <code>NULL</code> if conversion fails. </dd></dl>
<dl class="section remark"><dt>注釈</dt><dd>The patch must be of type eBSpline, eBezier or eLinear. </dd></dl>

</div>
</div>
<a id="afd5bc619771c69c680b2da7ae4d0c2e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd5bc619771c69c680b2da7ae4d0c2e4">&#9670;&nbsp;</a></span>ConvertPatchToNurbsSurfaceInPlace()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool FbxGeometryConverter::ConvertPatchToNurbsSurfaceInPlace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_fbx_node.html">FbxNode</a> *&#160;</td>
          <td class="paramname"><em>pNode</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Convert a patch contained in a node to a nurb surface. Use this function to preserve the patch's skins and shapes animation channels. </p><dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">pNode</td><td>Pointer to the node containing the patch. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd><code>true</code> on success, <code>false</code> if the node attribute is not a patch. </dd></dl>
<dl class="section remark"><dt>注釈</dt><dd>The patch must be of type eBSpline, eBezier or eLinear. </dd></dl>

</div>
</div>
<a id="a3c79ca6723b51b564842b9563f67102f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c79ca6723b51b564842b9563f67102f">&#9670;&nbsp;</a></span>EmulateNormalsByPolygonVertex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool FbxGeometryConverter::EmulateNormalsByPolygonVertex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_fbx_mesh.html">FbxMesh</a> *&#160;</td>
          <td class="paramname"><em>pMesh</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Emulate normals by polygon vertex mode for a mesh. </p><dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">pMesh</td><td>Pointer to the mesh object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd><code>true</code> on success, <code>false</code> if the number of normals in the mesh and in its associated shapes don't match the number of polygon vertices. </dd></dl>
<dl class="section remark"><dt>注釈</dt><dd>For applications that only supports normals by control points, this function duplicates control points to equal the number of polygon vertices. skins and shapes are also converted. As preconditions:<ol type="1">
<li>polygons must have been created</li>
<li>the number of normals in the mesh and in its associated shapes must match the number of polygon vertices. </li>
</ol>
</dd></dl>

</div>
</div>
<a id="a5b6352d91ef28ac20c8b759496064fa3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b6352d91ef28ac20c8b759496064fa3">&#9670;&nbsp;</a></span>FlipNurbs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_fbx_nurbs.html">FbxNurbs</a>* FbxGeometryConverter::FlipNurbs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_fbx_nurbs.html">FbxNurbs</a> *&#160;</td>
          <td class="paramname"><em>pNurbs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>pSwapUV</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>pSwapClusters</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Flip UV and/or skin clusters of a nurb. </p><dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">pNurbs</td><td>Pointer to the Source nurb. </td></tr>
    <tr><td class="paramname">pSwapUV</td><td>Set to <code>true</code> to swap the UVs. </td></tr>
    <tr><td class="paramname">pSwapClusters</td><td>Set to <code>true</code> to swap the control point indices of clusters. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>A flipped <a class="el" href="class_fbx_nurbs.html">FbxNurbs</a>, or <code>NULL</code> if the function fails. </dd></dl>

</div>
</div>
<a id="a1fcc73c0f44390bf3ac13f8a796e34de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1fcc73c0f44390bf3ac13f8a796e34de">&#9670;&nbsp;</a></span>FlipNurbsSurface()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_fbx_nurbs_surface.html">FbxNurbsSurface</a>* FbxGeometryConverter::FlipNurbsSurface </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_fbx_nurbs_surface.html">FbxNurbsSurface</a> *&#160;</td>
          <td class="paramname"><em>pNurbs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>pSwapUV</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>pSwapClusters</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Flip UV and/or skin clusters of a nurb surface. </p><dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">pNurbs</td><td>Pointer to the Source nurb surface. </td></tr>
    <tr><td class="paramname">pSwapUV</td><td>Set to <code>true</code> to swap the UVs. </td></tr>
    <tr><td class="paramname">pSwapClusters</td><td>Set to <code>true</code> to swap the control point indices of clusters. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>A flipped <a class="el" href="class_fbx_nurbs_surface.html">FbxNurbsSurface</a>, or <code>NULL</code> if the function fails. </dd></dl>

</div>
</div>
<a id="a0870c4520e42e88aaed5c5a8cca0c7ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0870c4520e42e88aaed5c5a8cca0c7ec">&#9670;&nbsp;</a></span>MergeMeshes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_fbx_node.html">FbxNode</a>* FbxGeometryConverter::MergeMeshes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_fbx_array.html">FbxArray</a>&lt; <a class="el" href="class_fbx_node.html">FbxNode</a> *&gt; &amp;&#160;</td>
          <td class="paramname"><em>pMeshNodes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pNodeName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_fbx_scene.html">FbxScene</a> *&#160;</td>
          <td class="paramname"><em>pScene</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Merge multiple meshes to one mesh. The method will merge: a) mesh vertex; b) mesh polygon; c) mesh edge; d) all mesh elements; only the layer 0 elements is merged. e) if there are skins for old mesh, merge these skins. The new skin clusters link to old skeletons.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">pMeshNodes</td><td>FBX nodes that hold multiple meshes. These meshes will be merged. </td></tr>
    <tr><td class="paramname">pNodeName</td><td>Name of new mesh node. </td></tr>
    <tr><td class="paramname">pScene</td><td>The scene that will contain the new mesh node. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>The new mesh node if merge successfully, otherwise NULL is returned. </dd></dl>
<dl class="section remark"><dt>注釈</dt><dd>This method creates a new mesh, leaving the source mesh unchanged. The transform of new mesh node is: translate (0, 0, 0), rotation (0, 0, 0), scale (1, 1, 1). For layer element material, normal, smoothing, UV set, vertex color, binormal, tangent and polygon group, if any mesh misses these element, the merge for this kind of element is skipped. For layer element crease, hole, visibility and user data, if any mesh has such element, the kind of element will be merged. The missing element will be filled with default values. For meshes with skin binding, if the pose of frame 0 is different with bind pose, the new mesh will be distorted. </dd></dl>

</div>
</div>
<a id="a26aa6da6240c0293e449958f8a58a779"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26aa6da6240c0293e449958f8a58a779">&#9670;&nbsp;</a></span>RecenterSceneToWorldCenter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool FbxGeometryConverter::RecenterSceneToWorldCenter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_fbx_scene.html">FbxScene</a> *&#160;</td>
          <td class="paramname"><em>pScene</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="fbxtypes_8h.html#a171e72a1c46fc15c1a6c9c31948c1c5b">FbxDouble</a>&#160;</td>
          <td class="paramname"><em>pThreshold</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Re-parent nodes at root node level under a new node to re-center them at world center. Basically, this function calculates the scene bounding box in world coordinates, and test if the center of that bounding box distance from the world center is larger or equal than the threshold. If true, a new node with the proper negative offset position will become the new parent of all nodes at root node level. </p><dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">pScene</td><td>The scene to process. </td></tr>
    <tr><td class="paramname">pThreshold</td><td>Threshold at which all nodes will be re-centered. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd><code>true</code> if any nodes were re-centered, otherwise <code>false</code>. </dd></dl>

</div>
</div>
<a id="ae9f8c321399875d9d5df3ae49ebf428d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9f8c321399875d9d5df3ae49ebf428d">&#9670;&nbsp;</a></span>RemoveBadPolygonsFromMeshes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void FbxGeometryConverter::RemoveBadPolygonsFromMeshes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_fbx_scene.html">FbxScene</a> *&#160;</td>
          <td class="paramname"><em>pScene</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_fbx_array.html">FbxArray</a>&lt; <a class="el" href="class_fbx_node.html">FbxNode</a> *&gt; *&#160;</td>
          <td class="paramname"><em>pAffectedNodes</em> = <code><a class="el" href="fbxarch_8h.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Cleanup or remove degenerated meshes. </p><dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">pScene</td><td>The scene to process. </td></tr>
    <tr><td class="paramname">pAffectedNodes</td><td>The list of nodes that have been affected by this operation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>注釈</dt><dd>If the cleaned-up mesh becomes invalid, it is removed entirely. </dd></dl>

</div>
</div>
<a id="aed7a7dd03d949e08e008262fd5b57421"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed7a7dd03d949e08e008262fd5b57421">&#9670;&nbsp;</a></span>SplitMeshesPerMaterial()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool FbxGeometryConverter::SplitMeshesPerMaterial </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_fbx_scene.html">FbxScene</a> *&#160;</td>
          <td class="paramname"><em>pScene</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>pReplace</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Split all the mesh in the scene per material. </p><dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">pScene</td><td>The scene to iterate through to split meshes. </td></tr>
    <tr><td class="paramname">pReplace</td><td>If <code>true</code>, replace the original mesh with new ones and delete the original meshes, but <em>only</em> if they got split into multiple meshes, otherwise they are left untouched. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd><code>true</code> if all splitable mesh were successfully split, <code>false</code> otherwise. </dd></dl>
<dl class="section remark"><dt>注釈</dt><dd>The function will still iterate through all meshes regardless if one fails to split, but will return false in that case. </dd></dl>

</div>
</div>
<a id="a3b48927a9d9394344598d1e9e80499bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b48927a9d9394344598d1e9e80499bf">&#9670;&nbsp;</a></span>SplitMeshPerMaterial()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool FbxGeometryConverter::SplitMeshPerMaterial </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_fbx_mesh.html">FbxMesh</a> *&#160;</td>
          <td class="paramname"><em>pMesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>pReplace</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Split mesh per material. </p><dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">pMesh</td><td>The mesh that will be split if it has multiple materials assigned. </td></tr>
    <tr><td class="paramname">pReplace</td><td>If <code>true</code>, replace the original mesh with new one and delete the original mesh, but <em>only</em> if they got split into multiple meshes, otherwise left untouched. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd><code>true</code> on success, <code>false</code> otherwise. </dd></dl>
<dl class="section remark"><dt>注釈</dt><dd>The function will fail if the mapped material is not per face (<a class="el" href="class_fbx_layer_element.html#a5a40e95db30ae9f94611dc3f1568af26a228dc5a768f2137313858ce986cba4cf">FbxLayerElement::eByPolygon</a>) or if a material is multi-layered. It will create as many meshes as there are materials applied to it. If one mesh have some polygons with material A, some polygons with material B, and some polygons with NO material, 3 meshes distinct will be created. The newly created meshes will be automatically attached to the same <a class="el" href="class_fbx_node.html">FbxNode</a> that holds the original <a class="el" href="class_fbx_mesh.html">FbxMesh</a>. If the original mesh have tangents, they will be regenerated on the new meshes. </dd></dl>

</div>
</div>
<a id="a472eeb2876199b239ce84807a5b4812b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a472eeb2876199b239ce84807a5b4812b">&#9670;&nbsp;</a></span>Triangulate() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool FbxGeometryConverter::Triangulate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_fbx_scene.html">FbxScene</a> *&#160;</td>
          <td class="paramname"><em>pScene</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>pReplace</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>pLegacy</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Triangulate all node attributes in the scene that can be triangulated. </p><dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">pScene</td><td>The scene to iterate through to triangulate meshes. </td></tr>
    <tr><td class="paramname">pReplace</td><td>If <code>true</code>, replace the original meshes with the new triangulated meshes on all the nodes, and delete the original meshes. Otherwise, original meshes are left untouched. </td></tr>
    <tr><td class="paramname">pLegacy</td><td>If <code>true</code>, use legacy triangulation method that does not support holes in geometry. Provided for backward compatibility. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd><code>true</code> if all node attributes that can be triangulated were triangulated successfully. </dd></dl>
<dl class="section remark"><dt>注釈</dt><dd>The function will still iterate through all meshes regardless if one fails to triangulate, but will return false in that case. This function currently only supports node attribute of type eMesh, ePatch, eNurbs or eNurbsSurface. </dd></dl>

</div>
</div>
<a id="aeef7518f4f50b7afc7e7f429eef8aa8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeef7518f4f50b7afc7e7f429eef8aa8d">&#9670;&nbsp;</a></span>Triangulate() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_fbx_node_attribute.html">FbxNodeAttribute</a>* FbxGeometryConverter::Triangulate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_fbx_node_attribute.html">FbxNodeAttribute</a> *&#160;</td>
          <td class="paramname"><em>pNodeAttribute</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>pReplace</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>pLegacy</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Triangulate a node attribute, if supported, and preserve the skins and shapes animation channels. </p><dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">pNodeAttribute</td><td>Pointer to the node containing the geometry to triangulate. </td></tr>
    <tr><td class="paramname">pReplace</td><td>If <code>true</code>, replace the original geometry with the new triangulated geometry on the nodes, and delete the original geometry. Otherwise, the original geometry is left untouched, the new one is added to the nodes, and becomes the default one. </td></tr>
    <tr><td class="paramname">pLegacy</td><td>If <code>true</code>, use legacy triangulation method that does not support holes in geometry. Provided for backward compatibility. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>The newly created node attribute if successful, otherwise NULL. If node attribute type is not supported by triangulation, it returns the original node attribute. </dd></dl>
<dl class="section remark"><dt>注釈</dt><dd>This function currently only supports node attribute of type eMesh, ePatch, eNurbs or eNurbsSurface. If the node attribute does not support triangulation, or if it is already triangulated, this function will return pNodeAttribute. </dd></dl>

</div>
</div>
<h2 class="groupheader">フレンドと関連関数の詳解</h2>
<a id="af608b805e0fdfadf8f73af0f1e948bf5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af608b805e0fdfadf8f73af0f1e948bf5">&#9670;&nbsp;</a></span>FbxWriter3ds</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class FbxWriter3ds</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<hr/>このクラス詳解は次のファイルから抽出されました:<ul>
<li>C:/github/FBXpythonSDK201701/FBXpythonSDK201701/2017.1/include/fbxsdk/utils/<a class="el" href="fbxgeometryconverter_8h_source.html">fbxgeometryconverter.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
構築: &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
